[{"title":"Linq取实体类集合中的某个属性转化为数组","date":"2018-11-09T02:00:00.000Z","path":"2018/11/09/diary-181109-01/","text":"123456789101112class Demo&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125;&#125;static void Main(string[] args)&#123; List&lt;Demo&gt; data = new List&lt;Demo&gt;(); string[] names = (from x in data select x.Name).ToArray(); //或者 string[] names = data.Select(x=&gt;x.Name).ToArray();&#125;","tags":[{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"},{"name":"2018-11","slug":"2018-11","permalink":"//xnu132.win/tags/2018-11/"},{"name":"Linq","slug":"Linq","permalink":"//xnu132.win/tags/Linq/"}]},{"title":"修改 Visual Studio 2013 C#类的模板文件","date":"2018-09-16T05:59:00.000Z","path":"2018/09/16/diary-180916-01/","text":"【说明：本文参考并引用了rootmn的博客文章】 通过修改 Visual Studio 2013 C#类的模板文件可实现在创建类的同时给类添加类说明以及版权信息等注释文本（其他语言同样适用） 更改如下目录下的模板文件即可实现：C:\\Program Files\\Microsoft Visual Studio 12.0\\Common7\\IDE\\ItemTemplates\\CSharp\\Code\\2052\\Class\\Class.cs (默认路径)如VS安装路径并非上述路径，可尝试：[安装目录]\\Common7\\IDE\\ItemTemplates\\CSharp\\Code\\2052\\Class\\Class.cs 将模板文件 “Class.cs” 用记事本打开在需要添加注释的位置加上自己的文本即可，以下代码供参考：12345678910111213141516171819202122232425//=====================================================//Copyright (C) 2013-$year$ rootmn LI//All rights reserved//CLR Version: $clrversion$//Item Name: $itemname$//Machine Name: $machinename$//namespace: $rootnamespace$//CS File Name: $safeitemname$//User Name: $username$//Create Year: $year$//Create Time: $time$//Author's Blog: http://www.xnu132.win //======================================================using System;using System.Collections.Generic;$if$ ($targetframeworkversion$ &gt;= 3.5)using System.Linq;$endif$using System.Text;$if$ ($targetframeworkversion$ &gt;= 4.5)using System.Threading.Tasks;$endif$namespace $rootnamespace$&#123; class $safeitemrootname$ &#123; &#125;&#125;","tags":[{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"},{"name":"2018-9","slug":"2018-9","permalink":"//xnu132.win/tags/2018-9/"},{"name":"visual studio","slug":"visual-studio","permalink":"//xnu132.win/tags/visual-studio/"}]},{"title":"同一个Winform程序在同一时间只允许运行一个","date":"2018-09-08T01:59:00.000Z","path":"2018/09/08/diary-180908-01/","text":"在program类的main函数中添加以下代码 12345678bool CreateNew;System.Threading.Mutex mutex = new System.Threading.Mutex(false, \"程序的名称\", out CreateNew);if (!CreateNew)&#123; MessageBox.Show(\"程序正在运行中!\", \"提示\"); Application.Exit(); return;&#125;","tags":[{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"},{"name":"2018-9","slug":"2018-9","permalink":"//xnu132.win/tags/2018-9/"},{"name":"WinForm","slug":"WinForm","permalink":"//xnu132.win/tags/WinForm/"}]},{"title":"Winform解决界面重绘闪烁的问题","date":"2018-08-16T08:55:00.000Z","path":"2018/08/16/diary-180816-01/","text":"在窗体或用户控件中重写CreateParams123456789protected override CreateParams CreateParams&#123; get &#123; CreateParams cp = base.CreateParams; cp.ExStyle |= 0x02000000; return cp; &#125;&#125;","tags":[{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"},{"name":"WinForm","slug":"WinForm","permalink":"//xnu132.win/tags/WinForm/"},{"name":"2018-8","slug":"2018-8","permalink":"//xnu132.win/tags/2018-8/"}]},{"title":"SQL中JOIN的作用","date":"2018-06-25T01:35:00.000Z","path":"2018/06/25/diary-180625-01/","text":"首先简单介绍一下JOIN语法table1:左表；table2:右表。 JOIN 按照功能大致分为如下三类： 1.INNER JOIN（内连接,或等值连接）：取得两个表中存在连接匹配关系的记录。 2.LEFT JOIN（左连接）：取得左表（table1）完全记录，即是右表（table2）并无对应匹配记录。 3.RIGHT JOIN（右连接）：与 LEFT JOIN 相反，取得右表（table2）完全记录，即是左表（table1）并无匹配对应记录。 (注意：mysql不支持Full join,不过可以通过UNION 关键字来合并 LEFT JOIN 与 RIGHT JOIN来模拟FULL join.) 接下来给出一个列子用于解释下面几种分类。如下两个表(A,B) 12345678910mysql&gt; select A.id,A.name,B.name from A,B where A.id=B.id;+----+-----------+-------------+| id | name | name |+----+-----------+-------------+| 1 | Pirate | Rutabaga || 2 | Monkey | Pirate || 3 | Ninja | Darth Vader || 4 | Spaghetti | Ninja |+----+-----------+-------------+4 rows in set (0.00 sec) INNER JOIN内连接，也叫等值连接，inner join产生同时符合A和B的一组数据。 1234567mysql&gt; select * from A inner join B on A.name = B.name;+----+--------+----+--------+| id | name | id | name |+----+--------+----+--------+| 1 | Pirate | 2 | Pirate || 3 | Ninja | 4 | Ninja |+----+--------+----+--------+ LEFT JOIN123456789101112mysql&gt; select * from A left join B on A.name = B.name;#或者：select * from A left outer join B on A.name = B.name;+----+-----------+------+--------+| id | name | id | name |+----+-----------+------+--------+| 1 | Pirate | 2 | Pirate || 2 | Monkey | NULL | NULL || 3 | Ninja | 4 | Ninja || 4 | Spaghetti | NULL | NULL |+----+-----------+------+--------+4 rows in set (0.00 sec) left join,（或left outer join:在Mysql中两者等价，推荐使用left join.）左连接从左表(A)产生一套完整的记录,与匹配的记录(右表(B)) .如果没有匹配,右侧将包含null。 如果想只从左表(A)中产生一套记录，但不包含右表(B)的记录，可以通过设置where语句来执行，如下： 12345678mysql&gt; select * from A left join B on A.name=B.name where A.id is null or B.id is null;+----+-----------+------+------+| id | name | id | name |+----+-----------+------+------+| 2 | Monkey | NULL | NULL || 4 | Spaghetti | NULL | NULL |+----+-----------+------+------+2 rows in set (0.00 sec) 同理，还可以模拟inner join. 如下： 12345678mysql&gt; select * from A left join B on A.name=B.name where A.id is not null and B.id is not null;+----+--------+------+--------+| id | name | id | name |+----+--------+------+--------+| 1 | Pirate | 2 | Pirate || 3 | Ninja | 4 | Ninja |+----+--------+------+--------+2 rows in set (0.00 sec) 求差集： 根据上面的例子可以求差集，如下： 1234567891011121314SELECT * FROM A LEFT JOIN B ON A.name = B.nameWHERE B.id IS NULLunionSELECT * FROM A right JOIN B ON A.name = B.nameWHERE A.id IS NULL;# 结果+------+-----------+------+-------------+| id | name | id | name |+------+-----------+------+-------------+| 2 | Monkey | NULL | NULL || 4 | Spaghetti | NULL | NULL || NULL | NULL | 1 | Rutabaga || NULL | NULL | 3 | Darth Vader |+------+-----------+------+-------------+ 再举个简单的栗子：有两表：a,b其中a表中的字段为a_id，b中的字段为b_id,b_no;记录如下： 1234567891011121314151617a:+------+| a_id |+------+| 2 || 3 || 5 |+------+b:+------+------+| b_id | b_no |+------+------+| 1 | 3 || 2 | 5 || 3 | 6 |+------+------+ 执行语句:select a.a_id,b.b_no from a left join b on (a.a_id=b.b_id and b.b_id&gt;5) 效果如下： 1234567+------+------+| a_id | b_no |+------+------+| 5 | 6 || 2 | null || 3 | null |+------+------+ Right join12345678910mysql&gt; select * from A right join B on A.name = B.name;+------+--------+----+-------------+| id | name | id | name |+------+--------+----+-------------+| NULL | NULL | 1 | Rutabaga || 1 | Pirate | 2 | Pirate || NULL | NULL | 3 | Darth Vader || 3 | Ninja | 4 | Ninja |+------+--------+----+-------------+4 rows in set (0.00 sec) 同left join。 Cross joincross join：交叉连接，得到的结果是两个表的乘积，即笛卡尔积 笛卡尔（Descartes）乘积又叫直积。假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}。可以扩展到多个集合的情况。类似的例子有，如果A表示某学校学生的集合，B表示该学校所有课程的集合，则A与B的笛卡尔积表示所有可能的选课情况。 1234567891011121314151617181920212223242526mysql&gt; select * from A cross join B;+----+-----------+----+-------------+| id | name | id | name |+----+-----------+----+-------------+| 1 | Pirate | 1 | Rutabaga || 2 | Monkey | 1 | Rutabaga || 3 | Ninja | 1 | Rutabaga || 4 | Spaghetti | 1 | Rutabaga || 1 | Pirate | 2 | Pirate || 2 | Monkey | 2 | Pirate || 3 | Ninja | 2 | Pirate || 4 | Spaghetti | 2 | Pirate || 1 | Pirate | 3 | Darth Vader || 2 | Monkey | 3 | Darth Vader || 3 | Ninja | 3 | Darth Vader || 4 | Spaghetti | 3 | Darth Vader || 1 | Pirate | 4 | Ninja || 2 | Monkey | 4 | Ninja || 3 | Ninja | 4 | Ninja || 4 | Spaghetti | 4 | Ninja |+----+-----------+----+-------------+16 rows in set (0.00 sec)#再执行：mysql&gt; select * from A inner join B; 试一试#在执行mysql&gt; select * from A cross join B on A.name = B.name; 试一试 实际上，在 MySQL 中（仅限于 MySQL） CROSS JOIN 与 INNER JOIN 的表现是一样的，在不指定 ON 条件得到的结果都是笛卡尔积，反之取得两个表完全匹配的结果。INNER JOIN 与 CROSS JOIN 可以省略 INNER 或 CROSS 关键字，因此下面的 SQL 效果是一样的： 123... FROM table1 INNER JOIN table2... FROM table1 CROSS JOIN table2... FROM table1 JOIN table2 Full join1234567891011121314mysql&gt; select * from A left join B on B.name = A.name -&gt; union -&gt; select * from A right join B on B.name = A.name;+------+-----------+------+-------------+| id | name | id | name |+------+-----------+------+-------------+| 1 | Pirate | 2 | Pirate || 2 | Monkey | NULL | NULL || 3 | Ninja | 4 | Ninja || 4 | Spaghetti | NULL | NULL || NULL | NULL | 1 | Rutabaga || NULL | NULL | 3 | Darth Vader |+------+-----------+------+-------------+6 rows in set (0.00 sec) 全连接产生的所有记录（双方匹配记录）在表A和表B。如果没有匹配,则对面将包含null。 性能分析等详细内容参考 → Mysql Join语法解析与性能分析 - BeginMan - 博客园 https://www.cnblogs.com/BeginMan/p/3754322.html（本文内容引用自）","tags":[{"name":"2018-6","slug":"2018-6","permalink":"//xnu132.win/tags/2018-6/"},{"name":"SQL","slug":"SQL","permalink":"//xnu132.win/tags/SQL/"}]},{"title":"数据契约（DataContract）","date":"2018-06-12T03:35:00.000Z","path":"2018/06/12/diary-180612-01/","text":"服务契约定义了远程访问对象和可供调用的方法，数据契约则是服务端和客户端之间要传送的自定义数据类型。 一旦声明一个类型为DataContract，那么该类型就可以被序列化在服务端和客户端之间传送，如下所示。 123456[DataContract]public class UserInfo&#123; //….&#125; 只有声明为DataContract的类型的对象可以被传送，且只有成员属性会被传递，成员方法不会被传递。WCF对声明为DataContract的类型提供更加细节的控制，可以把一个成员排除在序列化范围以外，也就是说，客户端程序不会获得被排除在外的成员的任何信息，包括定义和数据。默认情况下，所有的成员属性都被排除在外，因此需要把每一个要传送的成员声明为DataMember，如下所示。 123456789101112131415161718192021222324252627[DataContract]public class UserInfo&#123; [DataMember] public string UserName &#123; get; set; &#125; [DataMember] public int Age &#123; get; set; &#125; [DataMember] public string Location &#123; get; set; &#125; public string Zodiac &#123; get; set; &#125;&#125; 上面这段代码把UserInfo类声明为DataContract，将UserName、Age、Location这3个属性声明为DataMember（数据成员）。Zodiac成员没有被声明为DataMember，因此在交换数据时，不会传输Zodiac的任何信息。 DataContract也支持Name/Namespace属性，如同ServiceContract，Name和Namespace可以自定义名称和命名空间，客户端将使用自定义的名称和命名空间对DataContract类型进行访问。 声明为DataMember的成员也可以自定义客户端可见的名称，例如： 123456789101112[DataMember(Name=\"Name\")]public string UserName&#123; get; set;&#125;[DataMember(Name=\"Age\")]public int UserAge&#123; get; set;&#125; 除了Name和Namespace以外，DataMember还有以下参数，它们的含义分别如下。 （1）IsRequired：值为true时，要求序列化引擎检查对象是否存在该值；若无，则会有异常抛出。 （2）Order：bool类型值，值为true时，序列化和反序列化过程将会按成员定义的顺序进行，这对依赖于成员位置的反序列化过程无比重要。 （3）EmitDefaultvalue：为成员属性设置一个默认值。 一般情况下，将类型声明为DataContract就可以满足传送的需求了，不过特殊情况是难以避免的，这时就需要对要传送的SOAP消息进行更加精确的控制，MessageContract可以满足这种需求。 把一个类型声明为MessageContract，意味着它可以被序列化为SOAP消息，可以声明类型的成员为SOAP消息的各个部分，如Header、Body等，如下所示。 123456789101112131415161718192021222324[MessageContract]public class UserMessage&#123; private string user = String.Empty; private string authKey = String.Empty; [MessageBodyMember( Name = \"UserName\", Namespace = \"http://www.wcf.com\")] public string User &#123; get &#123; return user; &#125; set &#123; user = value; &#125; &#125; [MessageHeader( Name = \"AuthKey\", Namespace = \"http://www.wcf.com\", MustUnderstand = true )] public string AuthKey &#123; get &#123; return authKey; &#125; set &#123; this.authKey = value; &#125; &#125;&#125; User成员被声明为MessageBody（消息体）的一个成员，AuthKey被声明为消息头（MessageHeader）的一个成员。这个类将可以生成如下的SOAP消息。 1234567891011&lt;s:Envelope&gt; &lt;s:Header&gt; &lt;a:Action s:mustUnderstand=\"1\"&gt;http://UserMessage/Action&lt;/a:Action&gt; &lt;h:AuthKey s:mustUnderstand=\"1\" xmlns:h=\"http://www.wcf.com\"&gt;xxxx&lt;/h:AuthKey&gt; &lt;/s:Header&gt; &lt;s:Body&gt; &lt;UserMessage xmlns=\"Microsoft.WCF.Documentation\"&gt; &lt;User xmlns=\"http://www.wcf.com\"&gt;abcd&lt;/User&gt; &lt;/UserMessage&gt; &lt;/s:Body&gt; &lt;/s:Envelope&gt; MessageHeader中，MustUnderstand参数表示读取该头的程序必须能够识别头的内容，否则不能继续处理。Name/Namespace的作用与前面的元素相同。另有Relay参数，若为true，头的内容被接收到以后会在响应消息中回发给消息发送端。 转载自（数据契约（DataContract） - 子夜. - 博客园 https://www.cnblogs.com/Gavinzhao/archive/2010/06/01/1748736.html）","tags":[{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"},{"name":"2018-6","slug":"2018-6","permalink":"//xnu132.win/tags/2018-6/"}]},{"title":"几个值得收藏的.NET开源项目","date":"2018-05-29T03:08:00.000Z","path":"2018/05/29/diary-180509-01/","text":"① OpenAuth.NET “最好用的.NET权限工作流框架” 基于经典领域驱动设计的权限管理及快速开发框架，基于Martin Fowler企业级应用开发思想及全新技术组合（Asp.Net MVC、EF、AutoFac、WebAPI、Swagger、Json.Net等），核心模块包括：组织机构、角色用户、权限授权、表单设计、工作流等。它的架构精良易于扩展，是中小企业的首选。 #####","tags":[{"name":"2018-5","slug":"2018-5","permalink":"//xnu132.win/tags/2018-5/"}]},{"title":"WinForm图片拼接","date":"2018-02-20T12:08:00.000Z","path":"2018/02/20/diary-180220-01/","text":"基本思路在设定好的最终图像框中根据预设坐标值逐个绘制要拼接的图片 举个简单的例子 首先，创建一个Bitmap对象img，同时设置好最终图片的大小 然后，创建一个Graphics对象g，用于在Bitmap对象中绘制将要拼接的图片 根据设定的坐标，在Bitmap对象中相应位置绘制对应的图片，达到图片拼接的效果 将最终得到的Bitmap显示在PictureBox1中 关键代码：1234567Bitmap img = new Bitmap(40, 40);Graphics g = Graphics.FromImage(img);g.DrawImage(Image1, new Point(0, 0));g.DrawImage(Image2, new Point(20, 0));g.DrawImage(Image3, new Point(0, 20));g.DrawImage(Image4, new Point(20, 20));this.pictureBox1.Image = img; 待拼接图片： 拼接后：","tags":[{"name":"2018-2","slug":"2018-2","permalink":"//xnu132.win/tags/2018-2/"},{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"},{"name":"C#学习笔记","slug":"C-学习笔记","permalink":"//xnu132.win/tags/C-学习笔记/"}]},{"title":"Visual Studio在使用过程中遇到的一些问题","date":"2018-02-19T07:45:00.000Z","path":"2018/02/19/diary-180219-01/","text":"用于记录个人遇到的一些有关Visual Studio使用方面的小问题 自定义控件相关 在创建好自定义控件并运行时，弹出“未能找到程序集“D:\\C#%FBA···%A%B%C3.dll”。请确保路径正确。”异常的解决方法 通常，出现该异常的原因是项目路径名中包含了’C#’字样，将其重命名或是移到其他路径即可解决","tags":[{"name":"2018-2","slug":"2018-2","permalink":"//xnu132.win/tags/2018-2/"},{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"},{"name":"C#学习笔记","slug":"C-学习笔记","permalink":"//xnu132.win/tags/C-学习笔记/"}]},{"title":"【网页书签】","date":"2017-09-05T05:00:00.000Z","path":"2017/09/05/diary-170817-01/","text":"C# 线程间不能调用剪切板的问题 - 编程之家 - CSDN博客 C# 以MDF文件链接数据库 - 隔壁老王的博客 - CSDN博客 Markdown-入门指南及网站整合 - 努力在追梦的路上 - CSDN博客 Untitled - 马克飞象 - 专为印象笔记打造的Markdown编辑器 C# 自定义控件VS用户控件 - 野狼谷 - 博客园 【WinForm】创建自定义控件 - bomo - 博客园 C# 颜色Color与16进制互转 - Net-Spider - 博客园 C# MeasureString测量字符串函数的使用方法 C#教程 脚本之家 C# byte数组与Image的相互转换 - 阿凡卢 - 博客园 C# 将文件转化成字节数组 - 沙耶 - 博客园 C#的自定义滚动条 - 今木。非昔木 - 博客园 NAT路由器“打洞”技术，即P2P通信实现原理（非常详细） - CSDN博客 C# 使用ffmpeg.exe进行音频转换完整demo-xtyga330024 .net 调用 ffmpeg 转换音频文件amr - mp3 - mingxiu_wzdx的日志 - 网易博客 通过改hosts访问wikipedia - CSDN博客 winform实例(3)-利用摄像头进行拍照 - 智博的日常 - 博客园 GDI+ 中发生一般性错误 - 绿水青山 - 博客园","tags":[{"name":"教程","slug":"教程","permalink":"//xnu132.win/tags/教程/"},{"name":"2017-9","slug":"2017-9","permalink":"//xnu132.win/tags/2017-9/"},{"name":"书签","slug":"书签","permalink":"//xnu132.win/tags/书签/"}]},{"title":"来点纯音提提神吧","date":"2017-08-06T23:47:00.000Z","path":"2017/08/07/diary-170807-01/","text":"提神醒脑的一剂良药 😆 🎵🎶 点击打开网易云歌单","tags":[{"name":"音乐","slug":"音乐","permalink":"//xnu132.win/tags/音乐/"},{"name":"2017-8","slug":"2017-8","permalink":"//xnu132.win/tags/2017-8/"}]},{"title":"【日常随笔】 17-07-25","date":"2017-07-25T15:30:00.000Z","path":"2017/07/25/diary-170725-01/","text":"最近“闲”的时候干了这些事 👇👇👇 1、 云中转聊天程序的登录界面有所优化 用户可以点击登录界面左下角的小按钮通过用户名搜索自己的账号用以解决忘记账号而无法登录的尴尬虽然没什么人在用我这个所谓的“云中转聊天程序”聊天就是了😅 2、 由于网易云跟帖前段时间也宣布下线，本站的评论系统改为友言（目前已换成 来必力） 说实话，未备案域名无法使用畅言就已经让人很不爽了结果稍微差那么一丢丢但还看的过去的网易云跟帖居然宣布下线！？简直是屋漏偏逢连夜雨，于是只好选用了与主题极不搭调的友言由于技术不到位，布局不会调，新开的友言评论框简直没法看体验了一段时间之后，决定放弃友言现在已更换为来必力 -&gt;自学过程中编写的小程序&lt;-","tags":[{"name":"随笔","slug":"随笔","permalink":"//xnu132.win/tags/随笔/"},{"name":"2017-7","slug":"2017-7","permalink":"//xnu132.win/tags/2017-7/"}]},{"title":"C#创建非矩形窗体","date":"2017-07-24T04:30:00.000Z","path":"2017/07/24/diary-170724-01/","text":"简 介示例： 1、 C#根据含透明色的图片创建非矩形窗体 2、 鼠标左键控制该窗体的移动 （转载请注明出处） 具体操作1、 在新建立的窗体中拖入PictureBox控件 2、 设置好PictureBox的图片来源 3、 其属性SizeMode设置为StretchImage（拉伸） 4、 设置窗体背景色透明，在窗体加载事件中添加如下代码： 123this.TransparencyKey = Color.White; //设置当前窗体的默认透明色 this.BackColor = this.TransparencyKey; //设置当前窗体的背景色为透明 this.FormBorderStyle = FormBorderStyle.None; //设置窗体无边框 5、 让鼠标控制窗体的移动（详细代码见后文） 首先创建一个Point对象downPoint（用于记录鼠标移动前的坐标） 然后在PictureBox的MouseDown事件中将鼠标移动前的坐标e.Location赋值给downPoint 最后，在pictureBox的MouseMove事件中先判断当前按键是否为鼠标左键，若是，则通过鼠标移动前的坐标和移动后的坐标生成新的坐标赋值给当前的窗体 代 码1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace MainFrm&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; this.TransparencyKey = Color.White; //设置当前窗体的默认透明色 this.BackColor = this.TransparencyKey; //设置当前窗体的背景色为透明 this.FormBorderStyle = FormBorderStyle.None; //设置窗体无边框 &#125; Point downPoint; //用于记录鼠标移动前的位置 private void pictureBox1_MouseDown(object sender, MouseEventArgs e) &#123;//将鼠标移动前的位置赋值给downPoint downPoint = e.Location; &#125; private void pictureBox1_MouseMove(object sender, MouseEventArgs e) &#123; if (e.Button==MouseButtons.Left) &#123;//通过鼠标的移动前和移动后的坐标生成新的坐标 Location = new Point(Location.X + e.X - downPoint.X, Location.Y + e.Y - downPoint.Y); &#125; &#125; &#125;&#125; （本页地址：http://xnu132.win/2017/07/24/diary-170724-1/ ）","tags":[{"name":"教程","slug":"教程","permalink":"//xnu132.win/tags/教程/"},{"name":"2017-7","slug":"2017-7","permalink":"//xnu132.win/tags/2017-7/"},{"name":"C#","slug":"C","permalink":"//xnu132.win/tags/C/"}]},{"title":"【C#小程序】 云中转聊天","date":"2017-07-13T14:45:00.000Z","path":"2017/07/13/diary-170713-01/","text":"概 述C#小程序第二波 - - “云中转聊天”（EX-Chat） 基本功能完成于前些日子，更多功能还在探索中 缘 由“为什么想做这么个项目呢？” 本人在学习.NET的时候对使用Socket编程实现通信遇到的一些问题深有感触。当时懂的东西特少，以为只要在我的电脑连接网络开启Socket服务端，其他能连上网的电脑上的客户端就能连接得到。直到后来与同学在两个不同内网中测试自己写出来的程序的可用性的时候发现根本连不上，当时我还以为是自己将代码写错了才会导致这种情况，后来证明是当时的自己图样图森破。原来，Socket服务端要想让所有客户端都能连接到，必须得将其运行在连接了外网的服务器（或是电脑）上，或者还有一种方案就是对自己的电脑进行NAT穿透（也就是所谓的内网穿透吧）。苦于本人对NAT并不是特别了解，虽然知道有这么个方案，由于也没有很多空闲时间去学，于是就一直没能将其实现。没有连接到外网的电脑也不会用NAT怎么办呢？那么接下来这个项目就是介绍一种无服务器的简单通信方案。 思 路为了解决以上所说的那些问题，我的思路大致是这样的： 首先，准备工作 由于本人想的这个方案由于比较简单，所以要求也比较低，总的来说一个能用的云数据库则足以（云数据库可以上服务供应商官网购买，如果只是感兴趣想学学，你也可以上论坛找找看有没有免费试用的） 有了云数据库之后，我们先在云数据库上面建立一张初始表用于存储用户的数据，表中的相关字段根据自己的需要自行设置，以本人项目为例，我创建的用户数据表主要包含了七个字段：用户账号、用户名、用户密码、注册时间、在线状态、最后登录时间、用户类型。 接下来 就是使用VS进行用户界面的搭建了，主要包含登录、注册、好友列表、聊天界面四个窗体。因为跟本文主题不相关，这里不进行细说，每个人都有自己的想法，只要能实现基本的功能即可。 用户界面搭建好了之后，最关键的就是注册和聊天功能了。 注册时，用户填写相关信息，点击“注册”，客户端随机生成一个长度为5的数字作为账号，并将其与用户填写的信息一起写入到用户数据表中，同时建立一张专门用于存储该用户聊天记录的表，这也就完成了聊天功能（仅文字信息）的核心部分，最后就是如何实现客户端之间的通信了。 那么如何实现通信呢？既然有说到是数据库作数据中转，那么学过数据库的同学应该就能猜到是个什么想法了吧。 其实很简单，我利用的只不过就是数据库的增删查改功能。 这里简单的叙述一下消息的发送过程：本地用户在给对方发消息的时候，本地客户端在对方的聊天记录表上插入一条记录，而对方客户端在接收这条消息时则通过Timer控件定时检查对应账号的聊天记录表，如果有新的消息，则将其打印出来。反过来，对方给本地用户发消息也是同一个道理。 其他的比如清空消息记录之类功能，原理都大同小异，只要你会SQL脚本，相信这些实现起来都不难。 具体实现前阵子上阿里云申（ceng）请（xiao）域（pian）名（yi）的时候，顺便加价买了个共享虚拟主机普惠版。 由于廉价的一匹，得来的配置是这样的：200M的网页空间和20M的数据库空间，不过就目前来说，本人拿来学习和测试足以。 云虚拟主机被某帅比搁置了一段时间之后，终于在毫无特殊可言的某天下午迎来了它的使命。 由于是基于云数据库作数据中转的聊天程序，于是本人将项目名暂且取作“云中转聊天”（经过几个版本的迭代更新之后已更改为EX-Chat） 根据以上所述思路操作，经过多次修改，花费了好几天时间之后总算是写出了成品。 外观较为简陋，暂时只实现了基本的通信功能，并且安全性较低，只作学习和测试用。 下面放上几个主要窗体的相关截图用以参考，更多功能留作以后探索，更新日志见此处，这里暂不详述 点击此处下载程序（出于一些个人原因，下载接口暂时已关闭）– end 更新于：2017.11.20 end – 新版本的部分截图（1.0.4.8） 更新日志见此处 – end 更新于：2018.4.17 end –","tags":[{"name":"2017-7","slug":"2017-7","permalink":"//xnu132.win/tags/2017-7/"},{"name":"C#小程序","slug":"C-小程序","permalink":"//xnu132.win/tags/C-小程序/"}]},{"title":"【C#小程序】 ColorCreator","date":"2017-07-12T10:23:00.000Z","path":"2017/07/12/diary-170712-01/","text":"简 介ColorCreator是本渣于前段时间自学HTML和CSS时依照自己的需求用C#编写的 小小程序，并无太多的功能，简而言之就是 - - 展示十六进制颜色代码所对应的颜色 细 究当时在写HTML标签时遇到了一个问题，本渣不太清楚颜色的十六进制代码对应什么样的颜色 （汗！） 虽然这么串十六进制代码有它的规律，但是本渣并没有深究 原因很简单，懒 ~ 可能有人会说，“写到HTML的某个标签里上浏览器跑一下不就好了？” 的确，使用这种方式来查看颜色代码对应着什么样的颜色再方便不过 可是本渣就是喜欢折腾更加方便的method，(&gt; _ &lt;) 还是一个字，懒！ 我都懒得写到HTML里面了 直接复制粘贴，点一下生成按钮就可以看到结果多方便啊 基于这么个想法，本渣打开了vs 咔咔咔地撸了几行代码之后，一个小巧的颜色生成器就出来啦 实际结合TakeColor使用起来还确实挺方便的（TakeColor没有集成“通过十六进制代码生成颜色”这项功能） 不过吧，本渣并没有因此而感到满意 要是还能通过调节TakeColor上面那种小滑块来获得自己想要的颜色岂不美哉 想是这样想，不过距离上次这样想已经过去大概有三个月了吧 可是本渣至今没有行动，还是那个字、、 呵呵哒 、、以后再说以后再说 哈哈 截图奉上： 点击此处下载程序 点击此处查看源码 下面放上“生成”按钮的代码：1234567891011121314151617181920212223242526272829//点击生成按钮private void btnCreate_Click(object sender, EventArgs e)&#123; if (!string.IsNullOrEmpty(this.labelMsg.Text)) &#123; this.labelMsg.Text = \"\"; &#125; if (txtInput.Text.Length == 7) &#123; Bitmap bmp = new Bitmap(200, 150); Graphics g = Graphics.FromImage(bmp); string hex = this.txtInput.Text; try &#123; Color _color = System.Drawing.ColorTranslator.FromHtml(hex); Brush b = new SolidBrush(_color); g.FillRectangle(b, new Rectangle(0, 0, 200, 150)); this.picColorBoard.Image = bmp; &#125; catch &#123; labelMsg.Text = \"**请输入有效的十六进制码**\"; &#125; &#125; else &#123; labelMsg.Text = \"**请输入有效的十六进制码**\"; &#125;&#125; 后 记此为本渣第一篇用于 - - 记录【在自学.NET的道路上积累的经验】 并且 【收录个人鼓捣出的作品】 的文章 另外，本渣自己鼓捣出来的小程序的下载地址 看这里 仅用于学习和测试仅用于学习和测试仅用于学习和测试","tags":[{"name":"2017-7","slug":"2017-7","permalink":"//xnu132.win/tags/2017-7/"},{"name":"C#小程序","slug":"C-小程序","permalink":"//xnu132.win/tags/C-小程序/"}]},{"title":"【音乐分享】 アイロニ","date":"2017-06-24T04:23:00.000Z","path":"2017/06/24/diary-170624-01/","text":"人生って何なのって? 少し歩き疲れたんだ有些走累了啊少し歩き疲れたんだ有些走累了呢月並みな表現(ひょうげん)だけど雖然以那麼平凡的表現人生(じんせい)とかいう長い道を來形容人生漫長的道路少し休みたいんだ想稍稍休息下呢少し休みたいんだけど虽然想稍稍休息一下時間は刻一刻(こくいっこく)残酷と可是時間每時每刻都這樣殘酷私を 引っぱっていくんだ將我 緊拖著前行Yeah—— Yeah——Yeah—— うまくいきそうなんだけど雖然看似順利地進行著うまくいかないことばかりで但其實全是不順利的事迂闊(うかつ)にも泣いてしまいそうになる因此一塌糊塗地哭起來情(なさ)けない本当にな真是丟人呢惨(みじ)めな気持なんか這樣悲慘的感受嫌というほど味わってきたし已經不想再次體驗到了とっくに悔しさなんてものは明明應該將悔恨之類的捨ててきたはずなのに早早丟棄掉絶望抱くほど 悪いわけじゃないけど雖然也不是感到絕望般 那樣差勁欲しいものは いつも少し手には届かない但是想要的東西 卻永遠得不到手そんな半端(はんぱ)だとね對這樣沒用的傢伙なんか期待してしまうから為何會有所期待呢それならもういっそのこと既然如此不如乾脆ドン底まで突き落としてよ就將它推入穀底吧答えなんて言われたって即使要說出些什么答案人によってすり替(か)わってって因人不同也會有所改變だから絶対(ぜったい)なんて絶対所以絕對之類的絕對信じらんないよ ねぇ是不能相信的 對吧苦しみって誰にもあるって誰都會有苦楚そんなのわかってるから何だって說著那些什么都明白なら笑って済ませばいいの？那就笑著应对過去就好了吧？もうわかんないよ バカ！我不知道該怎麼辦啦 笨蛋！ 散々言われてきたくせに明明是被狠狠說了一番なんだ まんざらでもないんだ但卻未必就是這樣簡単に考えたら楽なことも將簡單思考起來很容易的事難関(なんかん)に考えてたんだ也當做難題考慮了段々(だんだん)と色々めんどくなって種種事都越發麻煩もう淡々と終わらせちゃおうか讓一切都淡泊結束吧「病んだ？」とかもう 嫌になったから「病了嗎？」之類的已經受夠了やんわりと終わればもういいじゃんか能溫和地結束不就好了嗎夢だとか希望だとか 生きてる意味とか夢也好希望也好 亦或是生存意義別にそんなものはさして 必要ないから那些東西也並不是 沒有必要存在具体的(ぐたいてき)でわかりやすい請給我具體易懂的機会(きかい)をください這樣的機會啊泣き場所探すうちに在尋找哭泣的地方時もう泣き疲れちゃったよ就已經哭累了啊きれいごとって嫌い だって討厭華而不實的話期待しちゃっても形になんなくて期待著卻捉不到蛛絲馬跡「星が僕ら見守って」って要說「星星守護著我們」夜しかいないじゃん ねぇ那也就只有晚上 對吧君のその優しいとこ你的那份溫柔不覚(ふかく)にも求めちゃうから我在不知不覺中尋求著この心やらかいとこ這顆心的柔軟もう触んないで ヤダ！請别再觸碰了 不要了啊！ もうほっといて不要再管我了啊もう置いてって就这样丟下我吧汚れきったこの道は弄髒了的這條路もう変わんないよ嗚呼已無法改變了啊疲れちゃって弱気(よわき)になって因疲倦而變得懦弱了逃げ出したって無駄なんだって想要逃也是白費力氣だから内面(ないめん)耳塞いで所以內心捂著耳朵もう最低(さいてい)だって泣いて已是最糟了而哭著人生って何なのって人生又是什麼呢わかんなくても生きてるだけで只是不明不白地活著幸せって思えばいいの？認為這即是幸福就可以了嗎？もうわかんないよ バカ！我不明白了啊 笨蛋！","tags":[{"name":"2017-6","slug":"2017-6","permalink":"//xnu132.win/tags/2017-6/"},{"name":"音乐","slug":"音乐","permalink":"//xnu132.win/tags/音乐/"}]},{"title":"【音乐分享】 一笑倾城","date":"2017-06-12T09:46:00.000Z","path":"2017/06/12/diary-170612-02/","text":"还有什么事情是一首音乐解决不了的？ 😃","tags":[{"name":"2017-6","slug":"2017-6","permalink":"//xnu132.win/tags/2017-6/"},{"name":"音乐","slug":"音乐","permalink":"//xnu132.win/tags/音乐/"}]},{"title":"MarkDown的使用教程","date":"2017-06-12T02:55:00.000Z","path":"2017/06/12/diary-170612-01/","text":"个人总结比较常用的几个 【标题】 123456# 标题1## 标题2### 标题3#### 标题4##### 标题5###### 标题6 【显示效果】 标题1标题2标题3标题4标题5标题6 【字体加粗】 1**目标文本** 【显示效果】 目标文本 【删除线】 1~~要删除的文本~~ 【显示效果】 要删除的文本 【字体倾斜】 1* 目标文本*（“ * ” 后方无空格） 【显示效果】 目标文本 【文字引用】 1&gt; 目标文本 【显示效果】 目标文本 【无序列表】（*、-、+ 均可） 将括号内的符号加到行的前面即可 通过空格缩进实现次级行显示 【有序列表】 在需要添加序号的行的前面添加“1. ”、“2. ”、“3. ”之类文本即可注意“.”后方有空格 【分割线】（“-”大于三个即可） 1------------ 【显示效果】 【直接链接】 1[百度](http://www.baidu.com \"百度\") 【显示效果】 百度 【引用链接】 12[百度][1][1]: http://www.baidu.com \"标题\" 【显示效果】 百度 【表格】 12345|左对齐|居中|右对齐||:---|:---:| ---:|| 1| 2| 3|| a| b| c|| ,| .| 、| 【显示效果】 左对齐 居中 右对齐 1 2 3 a b c , . 、 【github 特有的特性】 复选框列表 在列表符号后面加上[]或者[x]代表选中或者未选中情况1234567[x] C[x] C++[x] Java[x] Qt[x] Android[ ] C#[ ] .NET 【显示效果】 【表情显示】 1:blush: 【显示效果】 😊 更多表情请点击 这里 暂时就这么多吧网上教程很多，这里只列举某帅比觉得还不错的几个 其他教程如下： Markdown——入门指南【荐】 –&gt;传送门&lt;–（转自 Te_Lee的博客） Markdown 11中基本语法 –&gt;传送门&lt;–（转自 秋水Leo的博客） Markdown 语法 示例 字体 字号 颜色 –&gt;传送门&lt;–（转自 ABC-ruifeng的博客） Markdown 语法说明 (简体中文版) –&gt;传送门&lt;–（转自“小众软件”） Markdown: Basics （快速入门） (简体中文版) –&gt;传送门&lt;–（转自“小众软件”） Markdown 官方文档 创始人 John Gruber 的 Markdown 语法说明 Markdown 语法说明(简体中文版).pdf 编辑器推荐【Atom】 软件截图：","tags":[{"name":"2017-6","slug":"2017-6","permalink":"//xnu132.win/tags/2017-6/"},{"name":"教程","slug":"教程","permalink":"//xnu132.win/tags/教程/"},{"name":"Markdown","slug":"Markdown","permalink":"//xnu132.win/tags/Markdown/"}]},{"title":"沉迷二次元无法自拔😆","date":"2017-06-11T14:51:00.000Z","path":"2017/06/11/diary-170611-02/","text":"分享一组二次元美图⚠️⚠️⚠️前方多图预警（about 5~6 MB）⚠️⚠️⚠️","tags":[{"name":"2017-6","slug":"2017-6","permalink":"//xnu132.win/tags/2017-6/"},{"name":"二次元","slug":"二次元","permalink":"//xnu132.win/tags/二次元/"}]},{"title":"Starting point 2017.6.11","date":"2017-06-11T14:47:00.000Z","path":"2017/06/11/diary-170611-01/","text":"某只闲的蛋疼的帅比折腾了好几天浏览了无数博主发布的教程结合实际操作在经历了无数次失败，积累了不少经验之后终于找到了适合自己的方法搭建属于自己的博客（博客搭建的相关教程请访问本文末尾的跳转链接） 说 明 搭建方式：Hexo+Github，博客采用Litten大佬提供的主题 用 途：个人博客，记录和分享本人在程序猿这条不归路上的坎坷经历 体 会 使用Hexo搭建个人博客相对其他方法来说很方便，在发表博文时用户只需掌握少量Git指令以及Markdown语法即可快速实现 Hexo支持使用Markdown语法编辑博文，相较于直接写HTML标签和代码来说要方便不少，并且易于掌握 Markdown：一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。（ 百度百科传送门： Markdown ） 以下简要介绍使用Markdown在代码显示上的运用：bash代码（创建新的博文）1$ hexo new \"我的第一篇博文\" C#代码1234void ShowMsg()&#123; MessageBox.Show(\"博主是个大帅比！\");&#125; js代码1alert(&quot;JavaScript表示赞同！&quot;); 搭建经验及教程本人使用Hexo+Github搭建个人博客的想法来自一个学前端开发的学长 起初是通过访问他的博客正式开始接触“个人博客”这一领域。当时就是觉得拥有一个个人博客是一件挺酷炫的事情，所有知道我博客地址的人都能访问我的网站，浏览我写的博客，这是一件让人觉得很有成就感的事情。 写博客不但可以记录生活中发生的有意义的事情，还能提升自己的写作能力，那么我想这件事本身也很有意义吧。 想归想，要获得成就还是得有付出的。经过一番对于个人博客的初步了解之后，本渣渣总算是步入了个人博客搭建之路。 通过分析那位学长的网站以及他发过的博文，得知有Hexo这么一个框架。 Hexo是一个开源的静态博客生成器,用node.js开发,作者是台湾大学生tommy351。 而他使用的博客主题是由Litten设计开发的，能开发出这么简洁大气的博客主题，想必他也是很厉害的一个人吧！此处送上大佬的博客主页：Litten的博客 使用这种方法搭建个人博客对于我来说的难点是如何使用Hexo。一开始我对Hexo有个误解，一直以为Hexo的主题本身就是一个博客模板，只要把主题里面所有的文件放到github仓库就可以直接访问后来经历过多次失败后才发现事情并没有那么简单。 一番疯狂的学习和实践之后，本站总算是基本搭建完成。折腾了很久，切实验证了一个真理 - - “成功是需要多次尝试并且经历多次失败才能得来的”、、、 期间访问了很多个人博客，收藏了很多教程，按照这些教程一步一步操作，遇到不懂的就百度，相信大家也能很快拥有属于自己的博客 教 程 使用 Hexo 生成一套静态博客网页（主要） 参 考 史上最详细“截图”搭建Hexo博客并部署到Githu Hexo+GitHub Pages搭建属于自己的blog windows环境下使用hexo搭建blog平台 hexo常用命令笔记 github写博客 hexo你的博客 Hexo 主题制作指南 使用AES算法加密hexo文章 Hexo官方文档 本文到此就先告一段落、吧、、、","tags":[{"name":"2017-6","slug":"2017-6","permalink":"//xnu132.win/tags/2017-6/"},{"name":"杂谈","slug":"杂谈","permalink":"//xnu132.win/tags/杂谈/"},{"name":"随笔","slug":"随笔","permalink":"//xnu132.win/tags/随笔/"},{"name":"Github","slug":"Github","permalink":"//xnu132.win/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"//xnu132.win/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"//xnu132.win/tags/Blog/"},{"name":"教程","slug":"教程","permalink":"//xnu132.win/tags/教程/"}]}]